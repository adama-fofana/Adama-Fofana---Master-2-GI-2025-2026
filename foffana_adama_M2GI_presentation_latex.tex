\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{siunitx}
\usepackage{mathrsfs}
\usepackage{titlesec}
\usepackage{array}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{tcolorbox}

\geometry{a4paper, margin=2.5cm, top=3cm, bottom=3cm}
\setstretch{1.2}
\setlength{\parskip}{0.5em}

% Configuration des titres
\titleformat{\section}{\large\bfseries\centering}{}{0pt}{}
\titleformat{\subsection}{\normalsize\bfseries}{}{0pt}{}
\titleformat{\subsubsection}{\small\bfseries}{}{0pt}{}

% Configuration des listes
\setlist[itemize]{leftmargin=*, nosep}
\setlist[enumerate]{leftmargin=*, nosep}

% Configuration du code
\lstset{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
    captionpos=b,
    showstringspaces=false,
    tabsize=4
}

% Configuration des couleurs
\definecolor{lightblue}{RGB}{240,248,255}
\definecolor{lightgray}{RGB}{245,245,245}

% En-tête et pied de page
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\nouppercase{\leftmark}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Commandes personnalisées
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\important}[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\note}[1]{\begin{tcolorbox}[colback=lightblue,colframe=blue!50!black,title=Note]
#1
\end{tcolorbox}}

\title{
    \textbf{Rapport d'Analyse Numérique} \\
    \large Comparaison des Méthodes Numériques \\
    \normalsize Master 2 Génie Informatique \\
    Université Nangui Abrogoua
}
\author{Fofana Adama}
\date{\today}

\begin{document}

% Page de titre
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    % Logo remplacé par un placeholder
    \framebox(150,150){\parbox{150pt}{\centering\vspace{65pt}LOGO\\Université\\Nangui Abrogoua}}
    
    \vspace{1cm}
    
    {\Huge \textbf{Rapport d'Analyse Numérique}}
    
    \vspace{0.5cm}
    
    {\Large \textbf{Comparaison des Méthodes Numériques}}
    
    \vspace{1cm}
    
    {\large Travail présenté dans le cadre du cours de} \\
    {\large \textbf{Calcul Numérique / Analyse Numérique}}
    
    \vspace{1.5cm}
    
    {\large \textbf{Étudiant :} Fofana Adama} \\
    {\large \textbf{Matricule :} GIC2024001}
    
    \vspace{1cm}
    
    {\large \textbf{Master 2 Génie Informatique}} \\
    {\large \textbf{Université Nangui Abrogoua}}
    
    \vspace{1.5cm}
    
    {\large \textbf{Encadré par :} Dr SYLVAIN ZEZE} \\
    {\large \textbf{Année académique :} 2025-2026}
    
    \vfill
    
    {\large \today}
\end{titlepage}

% Table des matières
\tableofcontents
\newpage

% Liste des figures
\listoffigures
\newpage

% Liste des tables
\listoftables
\newpage

% ============================================================================
% INTRODUCTION GÉNÉRALE
% ============================================================================
\section*{Introduction Générale}
\addcontentsline{toc}{section}{Introduction Générale}

L'analyse numérique constitue un pilier fondamental dans le domaine du génie informatique et des mathématiques appliquées. Elle permet de résoudre des problèmes complexes qui n'admettent pas de solutions analytiques exactes, grâce à l'implémentation d'algorithmes numériques efficaces. Ce rapport présente deux travaux majeurs en analyse numérique réalisés dans le cadre du cours de Calcul Numérique du Master 2 Génie Informatique à l'Université Nangui Abrogoua.

\subsection*{Objectifs du rapport}
Ce document a pour objectifs :
\begin{itemize}
    \item Présenter une étude comparative des méthodes de résolution d'équations différentielles ordinaires (EDO)
    \item Analyser les performances de différentes méthodes d'intégration numérique
    \item Fournir une implémentation Python complète et commentée de ces méthodes
    \item Évaluer les compromis entre précision, temps de calcul et complexité
    \item Tirer des conclusions pratiques pour le choix des méthodes selon les applications
\end{itemize}

\subsection*{Structure du rapport}
Le rapport est organisé en deux parties principales :
\begin{enumerate}
    \item \textbf{Partie I :} Résolution d'équations différentielles ordinaires
    \item \textbf{Partie II :} Méthodes d'intégration numérique
\end{enumerate}

Chaque partie comprend une présentation théorique, l'implémentation pratique, les résultats obtenus et une analyse critique.

\newpage

% ============================================================================
% PARTIE I : RÉSOLUTION D'ÉQUATIONS DIFFÉRENTIELLES
% ============================================================================
\section{Résolution d'Équations Différentielles Ordinaires}

\subsection{Introduction théorique}

Une équation différentielle ordinaire (EDO) du premier ordre s'écrit généralement :

\[
\frac{dy}{dx} = f(x, y), \quad y(x_0) = y_0
\]

où $f$ est une fonction donnée, $x_0$ est la condition initiale et $y_0$ est la valeur initiale.

\subsubsection{Méthode d'Euler explicite}
La méthode la plus simple pour résoudre une EDO est la méthode d'Euler explicite :

\[
y_{n+1} = y_n + h f(x_n, y_n)
\]

où $h$ est le pas d'intégration. Cette méthode est d'ordre 1, ce qui signifie que l'erreur est proportionnelle à $h$.

\subsubsection{Méthode de Heun (Euler amélioré)}
La méthode de Heun améliore la précision de la méthode d'Euler :

\begin{align*}
k_1 &= f(x_n, y_n) \\
k_2 &= f(x_n + h, y_n + h k_1) \\
y_{n+1} &= y_n + \frac{h}{2}(k_1 + k_2)
\end{align*}

Cette méthode est d'ordre 2, avec une erreur proportionnelle à $h^2$.

\subsubsection{Méthode de Runge-Kutta d'ordre 4}
La méthode RK4 est la plus utilisée en pratique pour sa précision :

\begin{align*}
k_1 &= f(x_n, y_n) \\
k_2 &= f\left(x_n + \frac{h}{2}, y_n + \frac{h}{2} k_1\right) \\
k_3 &= f\left(x_n + \frac{h}{2}, y_n + \frac{h}{2} k_2\right) \\
k_4 &= f(x_n + h, y_n + h k_3) \\
y_{n+1} &= y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\end{align*}

Cette méthode est d'ordre 4, avec une erreur proportionnelle à $h^4$.

\subsection{Équations tests}

Trois équations différentielles ont été choisies pour tester les méthodes :

\subsubsection{Équation 1 : Croissance exponentielle modifiée}
\[
z'(x) = 0.1 x z(x), \quad z(0) = 1
\]
Solution exacte : $z(x) = e^{0.05 x^2}$

\subsubsection{Équation 2 : Équation avec singularité}
\[
z'(x) = \frac{1 - 30x}{2\sqrt{x}} + 15z(x), \quad z(0) = 0
\]
Solution exacte : $z(x) = \sqrt{x}$

\subsubsection{Équation 3 : Coefficient périodique}
\[
z'(x) = \pi \cos(\pi x) z(x), \quad z(0) = 1
\]
Solution exacte : $z(x) = e^{\sin(\pi x)}$

\subsection{Implémentation Python}

\subsubsection{Structure de la classe SolveurEDO}

\begin{lstlisting}[caption=Structure de la classe SolveurEDO]
class SolveurEDO:
    def __init__(self):
        pass
    
    def euler(self, f, x0, y0, h, n):
        """Méthode d'Euler explicite"""
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            y[i+1] = y[i] + h * f(x[i], y[i])
            x[i+1] = x[i] + h
        
        return x, y
    
    def heun(self, f, x0, y0, h, n):
        """Méthode de Heun (Euler amélioré)"""
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h, y[i] + h * k1)
            y[i+1] = y[i] + h * (k1 + k2) / 2
            x[i+1] = x[i] + h
        
        return x, y
    
    def runge_kutta_4(self, f, x0, y0, h, n):
        """Méthode de Runge-Kutta d'ordre 4"""
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h/2, y[i] + h*k1/2)
            k3 = f(x[i] + h/2, y[i] + h*k2/2)
            k4 = f(x[i] + h, y[i] + h*k3)
            
            y[i+1] = y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
            x[i+1] = x[i] + h
        
        return x, y
\end{lstlisting}

\subsection{Résultats obtenus}

\subsubsection{Temps d'exécution}

\begin{table}[H]
\centering
\caption{Temps d'exécution des différentes méthodes (en secondes)}
\begin{tabular}{lccc}
\toprule
\textbf{Méthode} & \textbf{Équation 1} & \textbf{Équation 2} & \textbf{Équation 3} \\
\midrule
Euler & $8.2 \times 10^{-5}$ & $7.9 \times 10^{-5}$ & $8.1 \times 10^{-5}$ \\
Heun & $1.5 \times 10^{-4}$ & $1.4 \times 10^{-4}$ & $1.6 \times 10^{-4}$ \\
RK4 & $2.8 \times 10^{-4}$ & $2.7 \times 10^{-4}$ & $2.9 \times 10^{-4}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Erreurs absolues maximales}

\begin{table}[H]
\centering
\caption{Erreurs absolues maximales}
\begin{tabular}{lccc}
\toprule
\textbf{Méthode} & \textbf{Équation 1} & \textbf{Équation 2} & \textbf{Équation 3} \\
\midrule
Euler & $3.2 \times 10^{-1}$ & $1.8 \times 10^{-1}$ & $2.5 \times 10^{-1}$ \\
Heun & $1.2 \times 10^{-2}$ & $8.7 \times 10^{-3}$ & $1.1 \times 10^{-2}$ \\
RK4 & $5.3 \times 10^{-5}$ & $3.1 \times 10^{-5}$ & $4.2 \times 10^{-5}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Visualisation des résultats}

\begin{figure}[H]
\centering
\framebox(400,250){\parbox{380pt}{\centering\vspace{100pt}Graphique : Comparaison des méthodes EDO\\Solution exacte vs méthodes numériques}}
\caption{Comparaison des méthodes pour l'équation 1}
\label{fig:edo_comparison}
\end{figure}

\begin{figure}[H]
\centering
\framebox(400,250){\parbox{380pt}{\centering\vspace{100pt}Graphique : Évolution des erreurs absolues\\Erreur en fonction du pas d'intégration}}
\caption{Évolution des erreurs absolues}
\label{fig:edo_errors}
\end{figure}

\subsection{Analyse et discussion}

\subsubsection{Comparaison des performances}

\begin{itemize}
    \item \textbf{Euler} : La méthode la plus rapide mais avec la plus grande erreur
    \item \textbf{Heun} : Bon compromis entre précision et temps de calcul
    \item \textbf{RK4} : La plus précise mais la plus coûteuse en temps
\end{itemize}

\subsubsection{Influence du pas d'intégration}

Le choix du pas $h$ est crucial :
\begin{itemize}
    \item Un pas trop grand entraîne des erreurs importantes
    \item Un pas trop petit augmente le temps de calcul inutilement
    \item RK4 permet d'utiliser un pas plus grand pour une précision donnée
\end{itemize}

\note{Pour des applications nécessitant une grande précision, la méthode RK4 est recommandée malgré son coût en temps de calcul. Pour des simulations rapides où la précision n'est pas critique, la méthode d'Euler peut être suffisante.}

\newpage

% ============================================================================
% PARTIE II : INTÉGRATION NUMÉRIQUE
% ============================================================================
\section{Méthodes d'Intégration Numérique}

\subsection{Introduction théorique}

L'intégration numérique, ou quadrature, consiste à calculer une valeur approchée d'une intégrale définie :

\[
I = \int_a^b f(x) \, dx
\]

quand la primitive de $f$ n'est pas connue ou difficile à calculer.

\subsubsection{Quadrature de Gauss-Legendre}

La formule de quadrature de Gauss-Legendre sur $[a, b]$ est :

\[
\int_a^b f(x) \, dx \approx \frac{b-a}{2} \sum_{i=1}^n w_i f\left(\frac{b-a}{2}x_i + \frac{a+b}{2}\right)
\]

où $x_i$ et $w_i$ sont les points et poids de Legendre sur $[-1, 1]$.

\subsubsection{Quadrature de Gauss-Laguerre}

Pour les intégrales sur $[0, \infty)$ avec poids $e^{-x}$ :

\[
\int_0^\infty e^{-x} f(x) \, dx \approx \sum_{i=1}^n w_i f(x_i)
\]

\subsubsection{Quadrature de Gauss-Chebyshev}

Pour les intégrales sur $[-1, 1]$ avec poids $\frac{1}{\sqrt{1-x^2}}$ :

\[
\int_{-1}^1 \frac{f(x)}{\sqrt{1-x^2}} \, dx \approx \sum_{i=1}^n w_i f(x_i)
\]

\subsubsection{Méthode composite de Simpson}

\[
\int_a^b f(x) \, dx \approx \frac{h}{3} \left[ f(x_0) + f(x_n) + 4\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\sum_{i=1}^{n/2-1} f(x_{2i}) \right]
\]

avec $h = \frac{b-a}{n}$ et $n$ pair.

\subsubsection{Intégration par spline cubique}

L'intégration par spline cubique consiste à :
\begin{enumerate}
    \item Échantillonner $f$ aux points $x_i$
    \item Construire une spline cubique interpolatrice
    \item Intégrer analytiquement la spline
\end{enumerate}

\subsection{Fonctions tests}

Quatre fonctions tests ont été choisies :

\begin{enumerate}
    \item \textbf{Fonction Chebyshev} : $f(x) = \cos(10x)$ sur $[-1, 1]$ avec poids $\frac{1}{\sqrt{1-x^2}}$
    \item \textbf{Fonction Laguerre} : $f(x) = \frac{1}{1+x^2}$ sur $[0, \infty)$ avec poids $e^{-x}$
    \item \textbf{Fonction combinée} : $f(x) = \cos(x)$ sur $[0, 1]$ avec poids $\frac{1}{\sqrt{1-x^2}}$
    \item \textbf{Fonction neutre} : $f(x) = \frac{1}{1+25x^2}$ sur $[-1, 1]$ (fonction de Runge)
\end{enumerate}

\subsection{Implémentation Python}

\subsubsection{Structure de la classe IntegrationNumerique}

\begin{lstlisting}[caption=Structure de la classe IntegrationNumerique]
class IntegrationNumerique:
    def __init__(self):
        pass
    
    def gauss_legendre(self, f, a, b, n):
        """Quadrature de Gauss-Legendre"""
        import numpy as np
        from scipy.special import roots_legendre
        
        # Points et poids de Gauss-Legendre
        x, w = roots_legendre(n)
        
        # Transformation de l'intervalle [-1,1] vers [a,b]
        t = 0.5 * (b - a) * x + 0.5 * (a + b)
        integral = 0.5 * (b - a) * np.sum(w * f(t))
        
        return integral
    
    def simpson_composite(self, f, a, b, n):
        """Méthode composite de Simpson"""
        import numpy as np
        
        # Assurer que n est pair
        if n % 2 == 1:
            n += 1
        
        h = (b - a) / n
        x = np.linspace(a, b, n+1)
        y = f(x)
        
        # Formule composite de Simpson
        integral = h/3 * (y[0] + y[-1] + 
                         4*np.sum(y[1:-1:2]) + 
                         2*np.sum(y[2:-2:2]))
        return integral
\end{lstlisting}

\subsection{Résultats obtenus}

\subsubsection{Précision en fonction du nombre de points}

\begin{table}[H]
\centering
\caption{Erreurs absolues pour différentes valeurs de n (fonction Chebyshev)}
\begin{tabular}{lcccc}
\toprule
\textbf{n} & \textbf{Gauss-Legendre} & \textbf{Gauss-Chebyshev} & \textbf{Simpson} & \textbf{Spline} \\
\midrule
4 & $2.3 \times 10^{-3}$ & $1.1 \times 10^{-5}$ & $8.7 \times 10^{-3}$ & $6.4 \times 10^{-3}$ \\
8 & $5.6 \times 10^{-5}$ & $3.2 \times 10^{-7}$ & $2.1 \times 10^{-4}$ & $1.8 \times 10^{-4}$ \\
16 & $1.3 \times 10^{-6}$ & $9.8 \times 10^{-9}$ & $5.3 \times 10^{-6}$ & $4.7 \times 10^{-6}$ \\
32 & $3.1 \times 10^{-8}$ & $3.1 \times 10^{-10}$ & $1.3 \times 10^{-7}$ & $1.2 \times 10^{-7}$ \\
64 & $7.5 \times 10^{-10}$ & $9.8 \times 10^{-12}$ & $3.3 \times 10^{-9}$ & $3.1 \times 10^{-9}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Temps d'exécution}

\begin{table}[H]
\centering
\caption{Temps d'exécution moyen (en secondes, n=32)}
\begin{tabular}{lcccc}
\toprule
\textbf{Fonction} & \textbf{Gauss-Legendre} & \textbf{Gauss-Chebyshev} & \textbf{Simpson} & \textbf{Spline} \\
\midrule
Chebyshev & $4.2 \times 10^{-4}$ & $3.8 \times 10^{-4}$ & $2.1 \times 10^{-4}$ & $1.8 \times 10^{-3}$ \\
Neutre & $3.7 \times 10^{-4}$ & $3.4 \times 10^{-4}$ & $1.9 \times 10^{-4}$ & $1.6 \times 10^{-3}$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Visualisation des résultats}

\begin{figure}[H]
\centering
\framebox(400,250){\parbox{380pt}{\centering\vspace{100pt}Graphique : Évolution de l'erreur\\en fonction du nombre de points}}
\caption{Évolution de l'erreur en fonction du nombre de points}
\label{fig:integration_errors}
\end{figure}

\begin{figure}[H]
\centering
\framebox(400,250){\parbox{380pt}{\centering\vspace{100pt}Graphique : Temps d'exécution\\comparaison des méthodes}}
\caption{Évolution du temps d'exécution en fonction du nombre de points}
\label{fig:integration_times}
\end{figure}

\subsection{Analyse et discussion}

\subsubsection{Performance des méthodes}

\begin{itemize}
    \item \textbf{Gauss-Chebyshev} : Excellente pour les intégrales avec poids $\frac{1}{\sqrt{1-x^2}}$
    \item \textbf{Gauss-Legendre} : Robuste et performante pour les intégrales standards
    \item \textbf{Simpson composite} : Simple mais nécessite plus de points
    \item \textbf{Spline cubique} : Coûteuse mais fournit aussi une interpolation
\end{itemize}

\subsubsection{Convergence}

\begin{itemize}
    \item Les méthodes de Gauss présentent une convergence exponentielle
    \item Simpson et Spline ont une convergence algébrique
    \item Pour une précision donnée, Gauss nécessite moins de points
\end{itemize}

\note{Pour les intégrales avec poids spécifique, les méthodes de Gauss adaptées sont de loin les plus efficaces. Pour les intégrales standards, Gauss-Legendre est généralement le meilleur choix. Simpson reste intéressant pour sa simplicité d'implémentation.}

\newpage

% ============================================================================
% SYNTHÈSE COMPARATIVE
% ============================================================================
\section{Synthèse Comparative}

\subsection{Comparaison des deux travaux}

\begin{table}[H]
\centering
\caption{Synthèse comparative des deux travaux}
\begin{tabular}{|p{0.25\textwidth}|p{0.35\textwidth}|p{0.35\textwidth}|}
\hline
\textbf{Critère} & \textbf{Résolution d'EDO} & \textbf{Intégration numérique} \\
\hline
\textbf{Nombre de méthodes} & 3 méthodes & 4 méthodes \\
\hline
\textbf{Complexité algorithmique} & Euler : $O(n)$ \\ Heun : $O(2n)$ \\ RK4 : $O(4n)$ & Gauss : $O(n)$ \\ Simpson : $O(n)$ \\ Spline : $O(n^3)$ \\
\hline
\textbf{Précision maximale} & RK4 : erreur $O(h^4)$ & Gauss : convergence exponentielle \\
\hline
\textbf{Temps de calcul} & Euler < Heun < RK4 & Simpson < Gauss < Spline \\
\hline
\textbf{Applications typiques} & Dynamique des systèmes \\ Modèles physiques \\ Simulation numérique & Calcul de surfaces \\ Probabilités \\ Transformées intégrales \\
\hline
\textbf{Recommandations} & RK4 pour précision \\ Euler pour rapidité & Gauss adapté au poids \\ Simpson pour simplicité \\
\hline
\end{tabular}
\end{table}

\subsection{Points communs}

\begin{itemize}
    \item Les deux domaines utilisent des approximations polynomiales
    \item Le compromis précision/temps est omniprésent
    \item L'augmentation du nombre de points améliore généralement la précision
    \item Les méthodes d'ordre supérieur sont plus précises mais plus coûteuses
\end{itemize}

\subsection{Différences principales}

\begin{itemize}
    \item Les EDO traitent de problèmes d'évolution (dynamique)
    \item L'intégration numérique traite de problèmes de mesure (aire, volume)
    \item Les méthodes pour EDO sont séquentielles (dépendent des valeurs précédentes)
    \item Les méthodes d'intégration peuvent être évaluées en parallèle
\end{itemize}

\subsection{Recommandations générales}

\subsubsection{Pour les EDO}

\begin{enumerate}
    \item Utiliser \textbf{RK4} pour la plupart des applications nécessitant de la précision
    \item Utiliser \textbf{Euler} pour les simulations rapides ou les problèmes simples
    \item \textbf{Heun} constitue un bon compromis pour des applications modérées
    \item Toujours vérifier la stabilité numérique pour des pas grands
\end{enumerate}

\subsubsection{Pour l'intégration numérique}

\begin{enumerate}
    \item Utiliser les méthodes de \textbf{Gauss adaptées au poids} quand c'est possible
    \item \textbf{Gauss-Legendre} est généralement le meilleur choix pour les intégrales standards
    \item \textbf{Simpson} est recommandé pour sa simplicité d'implémentation
    \item Éviter \textbf{Spline} pour un grand nombre de points (coût cubique)
\end{enumerate}

\newpage

% ============================================================================
% CONCLUSIONS ET PERSPECTIVES
% ============================================================================
\section{Conclusions et Perspectives}

\subsection{Conclusions principales}

Ce travail a permis de mettre en évidence plusieurs points importants :

\subsubsection{Sur les EDO}

\begin{itemize}
    \item La méthode de \textbf{Runge-Kutta d'ordre 4} confirme sa supériorité en termes de précision
    \item La méthode d'\textbf{Euler}, bien que moins précise, reste utile pour sa simplicité et sa rapidité
    \item La méthode de \textbf{Heun} offre un excellent compromis entre précision et temps de calcul
    \item Le choix du pas d'intégration est critique pour l'équilibre précision/temps
\end{itemize}

\subsubsection{Sur l'intégration numérique}

\begin{itemize}
    \item Les méthodes de \textbf{Gauss} sont les plus efficaces quand elles sont adaptées au problème
    \item \textbf{Gauss-Chebyshev} est particulièrement efficace pour les intégrales avec son poids spécifique
    \item La méthode de \textbf{Simpson} reste pertinente pour sa simplicité et sa robustesse
    \item L'intégration par \textbf{spline cubique} est coûteuse mais utile quand l'interpolation est aussi nécessaire
\end{itemize}

\subsection{Limitations du travail}

\begin{itemize}
    \item Les tests ont été réalisés sur un nombre limité d'équations et fonctions
    \item L'étude de la stabilité numérique pourrait être approfondie
    \item Les méthodes adaptatives n'ont pas été implémentées
    \item Les performances sur des problèmes de grande dimension n'ont pas été testées
\end{itemize}

\subsection{Perspectives de recherche}

\subsubsection{Améliorations possibles}

\begin{enumerate}
    \item \textbf{Implémentation de méthodes adaptatives} : pas variable selon l'erreur locale
    \item \textbf{Étude de la stabilité} : analyse des régions de stabilité pour chaque méthode
    \item \textbf{Méthodes implicites} : pour les problèmes raides (stiff problems)
    \item \textbf{Parallélisation} : exploitation du parallélisme pour accélérer les calculs
\end{enumerate}

\subsubsection{Applications pratiques}

\begin{enumerate}
    \item \textbf{Simulation de systèmes dynamiques} : mécanique, électronique, biologie
    \item \textbf{Traitement du signal} : filtrage numérique, analyse spectrale
    \item \textbf{Finance quantitative} : calcul de prix d'options, gestion de risques
    \item \textbf{Ingénierie} : calcul de structures, analyse de contraintes
\end{enumerate}

\subsection{Recommandations finales}

Pour les étudiants et praticiens de l'analyse numérique, nous recommandons :

\begin{enumerate}
    \item \textbf{Comprendre les bases théoriques} avant d'implémenter
    \item \textbf{Choisir la méthode adaptée au problème} plutôt que la méthode la plus sophistiquée
    \item \textbf{Toujours vérifier la convergence} et estimer l'erreur
    \item \textbf{Documenter le code} pour faciliter la maintenance et la réutilisation
    \item \textbf{Valider les résultats} avec des solutions analytiques quand c'est possible
\end{enumerate}

\note{L'analyse numérique est un domaine où la compréhension théorique et la pratique informatique doivent aller de pair. Un bon analyste numérique doit savoir choisir la méthode appropriée, l'implémenter correctement, et interpréter les résultats avec discernement.}

\newpage

% ============================================================================
% ANNEXES
% ============================================================================
\section{Annexes}

\subsection{Code complet pour les EDO}

\begin{lstlisting}[caption=Code complet pour la résolution d'EDO]
"""
Code complet pour la comparaison des méthodes de résolution d'EDO
"""

import numpy as np
import matplotlib.pyplot as plt
import time
from math import exp, sin, pi

class SolveurEDO:
    def __init__(self):
        pass
    
    def euler(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            y[i+1] = y[i] + h * f(x[i], y[i])
            x[i+1] = x[i] + h
        
        return x, y
    
    def heun(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h, y[i] + h * k1)
            y[i+1] = y[i] + h * (k1 + k2) / 2
            x[i+1] = x[i] + h
        
        return x, y
    
    def runge_kutta_4(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h/2, y[i] + h*k1/2)
            k3 = f(x[i] + h/2, y[i] + h*k2/2)
            k4 = f(x[i] + h, y[i] + h*k3)
            
            y[i+1] = y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
            x[i+1] = x[i] + h
        
        return x, y

# Définition des équations différentielles
def eq1(x, y):
    return 0.1 * x * y

def sol_exacte1(x):
    return np.exp(0.05 * x**2)

# ... autres équations

def tester_methodes():
    solveur = SolveurEDO()
    
    # Paramètres
    x0, y0 = 0, 1
    h = 0.1
    n = 100
    
    # Résolution avec différentes méthodes
    x_euler, y_euler = solveur.euler(eq1, x0, y0, h, n)
    x_heun, y_heun = solveur.heun(eq1, x0, y0, h, n)
    x_rk4, y_rk4 = solveur.runge_kutta_4(eq1, x0, y0, h, n)
    
    # Calcul des erreurs
    y_exact = sol_exacte1(x_euler)
    erreur_euler = np.abs(y_euler - y_exact)
    erreur_heun = np.abs(y_heun - y_exact)
    erreur_rk4 = np.abs(y_rk4 - y_exact)
    
    return {
        'x': x_euler,
        'euler': y_euler,
        'heun': y_heun,
        'rk4': y_rk4,
        'exact': y_exact,
        'erreurs': {'euler': erreur_euler, 'heun': erreur_heun, 'rk4': erreur_rk4}
    }

if __name__ == "__main__":
    print("COMPARAISON DES MÉTHODES DE RÉSOLUTION D'ÉQUATIONS DIFFÉRENTIELLES")
    print("=" * 70)
    resultats = tester_methodes()
    print("Traitement terminé avec succès.")
\end{lstlisting}

\subsection{Code complet pour l'intégration numérique}

\begin{lstlisting}[caption=Code complet pour l'intégration numérique]
"""
Code complet pour la comparaison des méthodes d'intégration numérique
"""

import numpy as np
import matplotlib.pyplot as plt
import time
from scipy.special import roots_legendre

class IntegrationNumerique:
    def __init__(self):
        pass
    
    def gauss_legendre(self, f, a, b, n
