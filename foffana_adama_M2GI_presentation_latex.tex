\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{siunitx}
\usepackage{mathrsfs}

\geometry{margin=2.5cm}
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
    captionpos=b
}

\title{Rapport d'Analyse Numérique : \\ Comparaison des Méthodes de Résolution \\ d'Équations Différentielles et d'Intégration Numérique}
\author{Fofana Adama \\ Master 2 Génie Informatique \\ Université Nangui Abrogoua}
\date{30 décembre 2024}

\begin{document}

\maketitle

\begin{abstract}
Ce rapport présente une étude comparative des méthodes numériques pour la résolution d'équations différentielles ordinaires et le calcul d'intégrales. Trois méthodes de résolution d'EDO (Euler explicite, Heun et Runge-Kutta d'ordre 4) sont comparées sur trois équations différentielles test. Parallèlement, cinq méthodes d'intégration numérique (Gauss-Legendre, Gauss-Laguerre, Gauss-Chebyshev, Simpson composite et spline cubique) sont évaluées sur quatre fonctions tests. Les critères de comparaison incluent la précision, le temps d'exécution et le taux de convergence.
\end{abstract}

\tableofcontents

\newpage

\section{Introduction}
\subsection{Contexte académique}
Ce travail s'inscrit dans le cadre du cours de Calcul Numérique (Analyse Numérique) du Master 2 Génie Informatique de l'Université Nangui Abrogoua. L'objectif est d'implémenter et de comparer différentes méthodes numériques fondamentales.

\subsection{Objectifs}
\begin{itemize}
    \item Implémenter les méthodes de résolution d'équations différentielles ordinaires
    \item Implémenter les méthodes d'intégration numérique par quadrature
    \item Comparer les performances en termes de précision et de temps d'exécution
    \item Analyser la convergence des différentes méthodes
    \item Identifier les méthodes les plus adaptées à différents types de problèmes
\end{itemize}

\section{Théorie Mathématique}

\subsection{Équations Différentielles Ordinaires (EDO)}
Une équation différentielle ordinaire du premier ordre s'écrit :
\[
\frac{dy}{dx} = f(x, y), \quad y(x_0) = y_0
\]

\subsubsection{Méthode d'Euler explicite}
La méthode d'Euler explicite est donnée par :
\[
y_{n+1} = y_n + h f(x_n, y_n)
\]
où $h$ est le pas d'intégration.

\subsubsection{Méthode de Heun (Euler amélioré)}
La méthode de Heun utilise une prédiction-corréction :
\begin{align*}
k_1 &= f(x_n, y_n) \\
k_2 &= f(x_n + h, y_n + h k_1) \\
y_{n+1} &= y_n + \frac{h}{2}(k_1 + k_2)
\end{align*}

\subsubsection{Méthode de Runge-Kutta d'ordre 4 (RK4)}
La méthode RK4 est donnée par :
\begin{align*}
k_1 &= f(x_n, y_n) \\
k_2 &= f\left(x_n + \frac{h}{2}, y_n + \frac{h}{2} k_1\right) \\
k_3 &= f\left(x_n + \frac{h}{2}, y_n + \frac{h}{2} k_2\right) \\
k_4 &= f(x_n + h, y_n + h k_3) \\
y_{n+1} &= y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\end{align*}

\subsection{Méthodes d'Intégration Numérique}

\subsubsection{Quadrature de Gauss-Legendre}
Pour l'intégrale $\displaystyle\int_a^b f(x)\, dx$, on utilise la formule :
\[
\int_a^b f(x)\, dx \approx \frac{b-a}{2} \sum_{i=1}^n w_i \, f\left(\frac{b-a}{2}x_i + \frac{a+b}{2}\right)
\]
où $x_i$ et $w_i$ sont les points et poids de Legendre sur $[-1, 1]$.

\subsubsection{Quadrature de Gauss-Laguerre}
Pour les intégrales sur $[0, \infty)$ avec poids $e^{-x}$ :
\[
\int_0^\infty e^{-x} f(x)\, dx \approx \sum_{i=1}^n w_i \, f(x_i)
\]

\subsubsection{Quadrature de Gauss-Chebyshev}
Pour les intégrales sur $[-1,1]$ avec poids $\dfrac{1}{\sqrt{1-x^2}}$ :
\[
\int_{-1}^1 \frac{f(x)}{\sqrt{1-x^2}}\, dx \approx \sum_{i=1}^n w_i \, f(x_i)
\]

\subsubsection{Méthode composite de Simpson}
\[
\int_a^b f(x)\, dx \approx \frac{h}{3} \left[ f(x_0) + f(x_n) + 4\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\sum_{i=1}^{n/2-1} f(x_{2i}) \right]
\]
avec $\displaystyle h = \frac{b-a}{n}$ et $n$ pair.

\section{Implémentation}

\subsection{Structure du code Python}
Le code est organisé en deux classes principales :
\begin{itemize}
    \item \texttt{SolveurEDO} pour les méthodes de résolution d'EDO
    \item \texttt{IntegrationNumerique} pour les méthodes d'intégration
\end{itemize}

\subsection{Équations différentielles testées}
\subsubsection{Équation 1}
\[
z'(x) = 0.1 x z(x), \quad z(0) = 1
\]
Solution exacte : $\displaystyle z(x) = e^{0.05 x^2}$

\subsubsection{Équation 2}
\[
z'(x) = \frac{1 - 30x}{2\sqrt{x}} + 15z(x), \quad z(0) = 0
\]
Solution exacte : $\displaystyle z(x) = \sqrt{x}$

\subsubsection{Équation 3}
\[
z'(x) = \pi \cos(\pi x) z(x), \quad z(0) = 1
\]
Solution exacte : $\displaystyle z(x) = e^{\sin(\pi x)}$

\subsection{Fonctions d'intégration testées}
\begin{enumerate}
    \item \textbf{Fonction Chebyshev} : $\displaystyle f(x) = \cos(10x)$ sur $[-1, 1]$ avec poids $\dfrac{1}{\sqrt{1-x^2}}$
    \item \textbf{Fonction Laguerre} : $\displaystyle f(x) = \frac{1}{1+x^2}$ sur $[0, \infty)$ avec poids $e^{-x}$
    \item \textbf{Fonction combinée} : $\displaystyle f(x) = \cos(x)$ sur $[0, 1]$ avec poids $\dfrac{1}{\sqrt{1-x^2}}$
    \item \textbf{Fonction neutre} : $\displaystyle f(x) = \frac{1}{1+25x^2}$ sur $[-1, 1]$
\end{enumerate}

\section{Résultats et Analyse}

\subsection{Comparaison des méthodes pour les EDO}

\subsubsection{Temps d'exécution}
Les temps d'exécution pour chaque méthode et chaque équation sont présentés dans le tableau suivant :

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Méthode} & \textbf{Équation 1 (s)} & \textbf{Équation 2 (s)} & \textbf{Équation 3 (s)} \\
\midrule
Euler & $t_{e1}$ & $t_{e2}$ & $t_{e3}$ \\
Heun & $t_{h1}$ & $t_{h2}$ & $t_{h3}$ \\
Runge-Kutta 4 & $t_{rk1}$ & $t_{rk2}$ & $t_{rk3}$ \\
\bottomrule
\end{tabular}
\caption{Temps d'exécution des méthodes pour les trois équations différentielles}
\label{tab:temps_edo}
\end{table}

\subsubsection{Erreurs absolues maximales}
\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Méthode} & \textbf{Équation 1} & \textbf{Équation 2} & \textbf{Équation 3} \\
\midrule
Euler & $e_{e1}$ & $e_{e2}$ & $e_{e3}$ \\
Heun & $e_{h1}$ & $e_{h2}$ & $e_{h3}$ \\
Runge-Kutta 4 & $e_{rk1}$ & $e_{rk2}$ & $e_{rk3}$ \\
\bottomrule
\end{tabular}
\caption{Erreurs absolues maximales (échelle logarithmique)}
\label{tab:erreurs_edo}
\end{table}

\subsection{Comparaison des méthodes d'intégration}

\subsubsection{Précision en fonction du nombre de points}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{graphiques_erreurs.png}
\caption{Évolution de l'erreur en fonction du nombre de points pour les quatre fonctions tests}
\label{fig:erreurs_integration}
\end{figure}

\subsubsection{Temps d'exécution en fonction du nombre de points}
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{graphiques_temps.png}
\caption{Évolution du temps d'exécution en fonction du nombre de points}
\label{fig:temps_integration}
\end{figure}

\section{Discussion}

\subsection{Performance des méthodes EDO}
\begin{itemize}
    \item \textbf{Méthode d'Euler} : La plus rapide mais la moins précise. Erreur de l'ordre de $\mathcal{O}(h)$.
    \item \textbf{Méthode de Heun} : Compromis entre précision et temps. Erreur de l'ordre de $\mathcal{O}(h^2)$.
    \item \textbf{Runge-Kutta 4} : La plus précise mais la plus coûteuse en temps. Erreur de l'ordre de $\mathcal{O}(h^4)$.
\end{itemize}

\subsection{Performance des méthodes d'intégration}
\begin{itemize}
    \item \textbf{Gauss-Chebyshev} : Excellente pour les intégrales avec poids $\dfrac{1}{\sqrt{1-x^2}}$.
    \item \textbf{Gauss-Laguerre} : Optimale pour les intégrales sur $[0, \infty)$ avec poids $e^{-x}$.
    \item \textbf{Gauss-Legendre} : Robuste pour les intégrales standards sur intervalles finis.
    \item \textbf{Simpson composite} : Simple à implémenter mais nécessite plus de points.
    \item \textbf{Spline cubique} : Coûteuse en temps mais fournit aussi une interpolation.
\end{itemize}

\subsection{Analyse de convergence}
Les méthodes de Gauss présentent une convergence exponentielle pour les fonctions analytiques, tandis que Simpson et les splines présentent une convergence algébrique.

\section{Conclusion}

\subsection{Principales conclusions}
\begin{enumerate}
    \item Pour les EDO, le choix de la méthode dépend du compromis précision/temps requis.
    \item Runge-Kutta 4 est recommandé pour les applications nécessitant une haute précision.
    \item Pour l'intégration numérique, les méthodes de Gauss adaptées au poids sont les plus efficaces.
    \item Gauss-Legendre est la méthode la plus polyvalente pour les intégrales standards.
    \item Simpson reste une bonne option pour des applications simples avec des fonctions régulières.
\end{enumerate}

\subsection{Perspectives}
\begin{itemize}
    \item Extension aux systèmes d'équations différentielles
    \item Implémentation de méthodes adaptatives
    \item Application à des problèmes physiques réels
    \item Étude de la stabilité numérique
\end{itemize}

\begin{thebibliography}{9}
\bibitem{quarteroni} Quarteroni, A., Saleri, F., \& Gervasio, P. (2010). \emph{Calcul scientifique}.
\bibitem{press} Press, W. H., Teukolsky, S. A., Vetterling, W. T., \& Flannery, B. P. (2007). \emph{Numerical Recipes}.
\bibitem{atkinson} Atkinson, K. E. (2008). \emph{An Introduction to Numerical Analysis}.
\bibitem{chapra} Chapra, S. C., \& Canale, R. P. (2010). \emph{Numerical Methods for Engineers}.
\end{thebibliography}

\appendix
\section{Code Python complet}

\subsection{Code pour les EDO}
Voici un extrait du code Python pour les méthodes de résolution d'EDO :

\begin{lstlisting}[language=Python, caption=Implémentation des méthodes de résolution d'EDO]
class SolveurEDO:
    def __init__(self):
        pass
    
    # Méthode d'Euler explicite
    def euler(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            y[i+1] = y[i] + h * f(x[i], y[i])
            x[i+1] = x[i] + h
        
        return x, y
    
    # Méthode de Heun (Euler amélioré)
    def heun(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h, y[i] + h * k1)
            y[i+1] = y[i] + h * (k1 + k2) / 2
            x[i+1] = x[i] + h
        
        return x, y
    
    # Méthode de Runge-Kutta d'ordre 4
    def runge_kutta_4(self, f, x0, y0, h, n):
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + h/2, y[i] + h*k1/2)
            k3 = f(x[i] + h/2, y[i] + h*k2/2)
            k4 = f(x[i] + h, y[i] + h*k3)
            
            y[i+1] = y[i] + h * (k1 + 2*k2 + 2*k3 + k4) / 6
            x[i+1] = x[i] + h
        
        return x, y
\end{lstlisting}

\subsection{Code pour l'intégration numérique}
\begin{lstlisting}[language=Python, caption=Implémentation des méthodes d'intégration]
class IntegrationNumerique:
    def __init__(self):
        pass
    
    # Quadrature de Gauss-Legendre
    def gauss_legendre(self, f, a, b, n):
        if b == np.inf:
            def g(t):
                x = t / (1 - t**2) if t != 1 else np.inf
                return f(x) * (1 + t**2) / (1 - t**2)**2
            a_tr = -0.999
            b_tr = 0.999
        else:
            g = f
            a_tr = a
            b_tr = b
        
        x, w = roots_legendre(n)
        t = 0.5 * (b_tr - a_tr) * x + 0.5 * (a_tr + b_tr)
        integral = 0.5 * (b_tr - a_tr) * np.sum(w * g(t))
        
        return integral
\end{lstlisting}

\section{Annexes techniques}
\subsection{Calcul des valeurs exactes}
\subsubsection{Fonction de Bessel}
Pour l'intégrale de Chebyshev :
\[
\int_{-1}^{1} \frac{\cos(10x)}{\sqrt{1-x^2}} \, dx = \pi J_0(10)
\]
où $J_0$ est la fonction de Bessel de première espèce d'ordre 0.

\subsubsection{Intégrale exponentielle}
Pour l'intégrale de Laguerre :
\[
\int_{0}^{\infty} \frac{e^{-x}}{1+x^2} \, dx = \text{Ci}(1)\sin(1) + \left(\frac{\pi}{2} - \text{Si}(1)\right)\cos(1)
\]
où Si et Ci sont les intégrales sinus et cosinus.

\end{document}
